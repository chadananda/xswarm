---
import terminalScenarios from '../data/terminal-scenarios.json';

export interface Props {
  projectName?: string;
  scenarioId?: string;
}

const { projectName = 'my-sass' } = Astro.props;

// Get all scenario IDs
const scenarioIds = Object.keys(terminalScenarios.scenarios);
// Start with the Spanish learning scenario
const defaultScenarioId = 'cognate-spanish-learning';
const currentScenarioId = scenarioIds.includes(defaultScenarioId) ? defaultScenarioId : scenarioIds[0];

// Prepare all scenarios for rotation
const allScenarios = {};
scenarioIds.forEach(id => {
  const scenario = terminalScenarios.scenarios[id];
  // Use the scenario's own projectName if available, otherwise use the prop
  const scenarioProjectName = scenario.projectName || projectName;
  allScenarios[id] = JSON.parse(JSON.stringify(scenario).replace(/{projectName}/g, scenarioProjectName));
});
---

<div class="terminal-hero-container">
  <!-- Main tagline above terminal -->
  <div class="hero-tagline-top">
    <h1 class="hero-title glitch-text" data-text="Be the Team You Wish to Lead">
      Be the Team You Wish to <span class="text-gradient-cyber">Lead</span>
    </h1>
    <p class="hero-subtitle">
      Someday, smart agents will collaborate automatically on software development. But until then, we can still get the quality we're after by heavily front-loading planning to ensure implementation can be correct, high-quality, efficient and massively parallel.
    </p>
  </div>

  <div class="terminal-window">
    <!-- Terminal header -->
    <div class="terminal-header">
      <div class="terminal-buttons">
        <span class="terminal-button terminal-button-red"></span>
        <span class="terminal-button terminal-button-yellow"></span>
        <span class="terminal-button terminal-button-green"></span>
      </div>
      <div class="terminal-title">{allScenarios[currentScenarioId].terminalTitle}</div>
    </div>
    
    <!-- Terminal content -->
    <div class="terminal-content" 
         data-scenarios={JSON.stringify(allScenarios)}
         data-scenario-ids={JSON.stringify(scenarioIds)}
         data-current-scenario={currentScenarioId}>
      <div class="terminal-lines">
        <!-- Initial prompt with blinking cursor -->
        <div class="terminal-line initial-prompt">
          <span class="terminal-prompt">$</span>
          <span class="initial-cursor"></span>
        </div>
        <!-- Dynamic content will be generated by JavaScript -->
      </div>
      
      <!-- Full screen chat interface -->
      <div class="chat-interface" data-delay="12000" style="display: none;">
        <!-- Dynamic chat content will be generated by JavaScript -->
      </div>
    </div>
  </div>
</div>
<style>
  /* Terminal color definitions - keep these in the component */
  :root {
    --terminal-green: rgb(0, 255, 0);
    --terminal-cyan: rgb(0, 255, 255);
    --terminal-yellow: rgb(255, 255, 0);
    --terminal-red: rgb(255, 0, 64);
    --terminal-magenta: rgb(255, 0, 255);
    --terminal-bg: rgb(10, 10, 10);
    --terminal-font-family: 'VT323', 'Courier New', 'Courier', monospace;
  }
  
  .terminal-hero-container {
    min-height: 80vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 2rem 1rem;
    background: var(--terminal-bg);
    gap: 3rem;
    position: relative;
    overflow: hidden;
  }
  
  /* Hero tagline outside terminal */
  .hero-tagline-top {
    text-align: center;
    opacity: 0;
    animation: fadeIn 1s ease-out forwards;
  }
  
  .terminal-hero-container .terminal-window {
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
    font-family: var(--terminal-font-family);
  }
  
  .terminal-hero-container .terminal-content {
    padding: 0;
    height: 42vh;
    max-height: 450px;
    min-height: 350px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    position: relative;
    background: var(--terminal-bg);
    /* Hide scrollbar but keep scroll functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
  }
  
  /* Hide scrollbar for Chrome, Safari and Opera */
  .terminal-hero-container .terminal-content::-webkit-scrollbar {
    display: none;
  }
  
  /* Add scanline effect to entire terminal content */
  .terminal-hero-container .terminal-content::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0, 255, 0, 0.03) 2px,
      rgba(0, 255, 0, 0.03) 4px
    );
    pointer-events: none;
    animation: scanlines 8s linear infinite;
    z-index: 999;
  }
  
  .terminal-lines {
    font-family: var(--terminal-font-family);
    font-size: 24px;
    line-height: 1.4;
    padding: 1.5rem 2rem 0.5rem 2rem;
    overflow-y: auto;
    flex: 1;
    /* Hide scrollbar but keep scroll functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
  }
  
  /* Hide scrollbar for Chrome, Safari and Opera */
  .terminal-lines::-webkit-scrollbar {
    display: none;
  }
  
  .terminal-line {
    opacity: 0;
    animation: fadeIn 0.3s ease-in forwards;
    margin-bottom: 0.5rem;
    min-height: 1.3em;
  }
  
  .terminal-prompt {
    color: var(--terminal-cyan);
    margin-right: 0.75rem;
    text-shadow: 0 0 3px var(--terminal-cyan), 0 0 8px rgba(0, 255, 255, 0.5);
    font-weight: 600;
  }
  
  .terminal-prompt::after {
    content: ' ';
  }
  
  /* Initial cursor styling */
  .initial-cursor {
    display: inline-block;
    width: 2px;
    height: 1.2em;
    background: var(--terminal-green);
    animation: blink 1s step-end infinite;
    vertical-align: text-bottom;
    margin-left: 0.5rem;
    box-shadow: 0 0 5px var(--terminal-green);
  }
  
  @keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
  }
  
  .terminal-command {
    color: var(--terminal-green);
    text-shadow: 0 0 3px var(--terminal-green), 0 0 8px rgba(0, 255, 0, 0.5);
    font-family: inherit;
  }
  
  /* Branch creation styles */
  .branch-creation-section {
    margin-top: 2rem;
    padding: 0 1rem;
  }
  
  .terminal-divider {
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--terminal-cyan), transparent);
    margin: 1.5rem 0;
    opacity: 0.5;
  }
  
  .branch-status {
    margin: 1rem 0;
    text-align: center;
  }
  
  .creating-branch {
    display: inline-flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem 1.5rem;
    background: rgba(0, 255, 255, 0.1);
    border: 1px solid var(--terminal-cyan);
    border-radius: 4px;
    color: var(--terminal-cyan);
    font-size: 1rem;
  }
  
  .branch-icon {
    font-size: 1.3rem;
    animation: pulse 1s ease-in-out infinite;
  }
  
  .branch-text {
    color: var(--terminal-cyan);
  }
  
  .building-animation {
    margin: 2rem 0;
    text-align: center;
  }
  
  .building-text {
    color: var(--terminal-cyan);
    font-size: 1.1rem;
    margin-bottom: 1.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
  }
  
  .planning-stages {
    margin-bottom: 1.5rem;
    text-align: left;
    max-width: 500px;
    margin-left: auto;
    margin-right: auto;
  }
  
  .planning-stage {
    margin-bottom: 0.5rem;
    opacity: 0;
    transform: translateX(-20px);
    animation: slideInStage 0.3s ease-out forwards;
  }
  
  @keyframes slideInStage {
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }
  
  .stage-icon {
    color: var(--terminal-green);
    margin-right: 0.5rem;
    display: inline-block;
    transition: transform 0.3s ease;
  }
  
  /* System indicator for planning messages */
  .system-indicator {
    color: var(--terminal-magenta);
    font-weight: 600;
    margin-right: 0.75rem;
  }
  
  .stage-indicator {
    color: var(--terminal-cyan);
    margin-right: 0.5rem;
    display: inline-block;
    width: 1rem;
  }
  
  .planning-stage.complete .stage-icon {
    content: '✓';
    color: var(--terminal-green);
    transform: rotate(90deg);
  }
  
  .stage-text {
    color: var(--terminal-yellow);
    font-size: 0.9rem;
  }
  
  .planning-stage.complete .stage-text {
    color: var(--terminal-green);
    opacity: 0.8;
  }
  
  .building-icon {
    animation: spin 2s linear infinite;
    display: inline-block;
    font-size: 1.5rem;
  }
  
  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }
  
  .progress-dots::after {
    content: '';
    animation: dots 1.5s steps(4, end) infinite;
  }
  
  @keyframes dots {
    0%, 20% { content: ''; }
    40% { content: '.'; }
    60% { content: '..'; }
    80%, 100% { content: '...'; }
  }
  
  .progress-bar {
    width: 100%;
    max-width: 400px;
    height: 4px;
    background: rgba(0, 255, 255, 0.1);
    border-radius: 2px;
    margin: 0 auto;
    overflow: hidden;
  }
  
  .progress-fill {
    height: 100%;
    background: var(--terminal-cyan);
    box-shadow: 0 0 10px var(--terminal-cyan);
    width: 0;
    animation: fillProgress 10s ease-out forwards;
  }
  
  @keyframes fillProgress {
    to { width: 100%; }
  }
  
  /* Continuous progress indicator */
  .continuous-progress {
    margin: 2rem auto;
    max-width: 600px;
    text-align: center;
  }
  
  .progress-status {
    color: var(--terminal-green);
    font-size: 0.9rem;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
  }
  
  .progress-spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid rgba(0, 255, 255, 0.3);
    border-top-color: var(--terminal-cyan);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  
  .progress-bar-continuous {
    width: 100%;
    height: 6px;
    background: rgba(0, 255, 255, 0.1);
    border-radius: 3px;
    overflow: hidden;
    position: relative;
  }
  
  .progress-wave {
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, 
      transparent, 
      var(--terminal-cyan) 20%, 
      var(--terminal-cyan) 80%, 
      transparent);
    animation: wave 2s linear infinite;
  }
  
  @keyframes wave {
    to { left: 100%; }
  }
  
  .dashboard-link {
    text-align: center;
    animation: fadeIn 0.5s ease-out forwards;
  }
  
  .link-text {
    color: var(--terminal-green);
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
  }
  
  .success-icon {
    color: var(--terminal-green);
    font-size: 1.2rem;
  }
  
  .dashboard-button {
    display: inline-flex;
    align-items: center;
    gap: 0.75rem;
    padding: 1rem 2rem;
    background: rgba(0, 255, 255, 0.1);
    border: 2px solid var(--terminal-cyan);
    border-radius: 4px;
    color: var(--terminal-cyan);
    text-decoration: none;
    font-size: 1.1rem;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }
  
  .dashboard-button:hover {
    background: rgba(0, 255, 255, 0.2);
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
    transform: translateY(-2px);
  }
  
  .button-icon {
    font-size: 1.3rem;
  }
  
  .button-arrow {
    transition: transform 0.3s ease;
  }
  
  .dashboard-button:hover .button-arrow {
    transform: translateX(4px);
  }
  
  /* Chat dashboard link */
  .chat-dashboard-link {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    color: var(--terminal-cyan);
    text-decoration: none;
    padding: 0.5rem 1rem;
    background: rgba(0, 255, 255, 0.1);
    border: 1px solid var(--terminal-cyan);
    border-radius: 4px;
    font-size: 0.85rem;
    transition: all 0.3s ease;
    margin-left: 2rem;
  }
  
  .chat-dashboard-link:hover {
    background: rgba(0, 255, 255, 0.2);
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    transform: translateY(-1px);
  }
  
  .link-icon {
    font-size: 1rem;
  }
  
  .share-link {
    margin-top: 1.5rem;
    padding: 1rem;
    background: rgba(0, 255, 255, 0.05);
    border-radius: 4px;
  }
  
  .share-text {
    display: block;
    color: var(--terminal-green);
    font-size: 0.9rem;
    margin-bottom: 0.5rem;
  }
  
  .share-url {
    display: block;
    padding: 0.5rem 1rem;
    background: var(--terminal-bg);
    border: 1px solid var(--terminal-green);
    border-radius: 4px;
    color: var(--terminal-yellow);
    font-family: var(--terminal-font);
    font-size: 0.85rem;
    user-select: all;
    cursor: pointer;
  }
  
  .share-url:hover {
    background: rgba(0, 255, 255, 0.1);
  }
  
  .typing-animation {
    display: inline-block;
    border-right: 2px solid var(--terminal-green);
    vertical-align: baseline;
    min-width: 1px;
    text-shadow: 0 0 2px currentColor, 0 0 5px rgba(0, 255, 255, 0.2);
  }
  
  .typing-animation.active {
    animation: blink-caret 0.75s step-end infinite;
  }
  
  @keyframes typing {
    from { width: 0; }
    to { width: 100%; }
  }
  
  @keyframes blink-caret {
    from, to { border-color: transparent; }
    50% { border-color: var(--terminal-green); }
  }
  
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  .terminal-loading {
    color: var(--terminal-yellow);
    animation: pulse 1s ease-in-out infinite;
    font-family: inherit;
  }
  
  @keyframes pulse {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
  }
  
  .terminal-success {
    color: var(--terminal-green);
    font-family: inherit;
  }
  
  /* ASCII Explosion */
  .ascii-explosion {
    opacity: 0;
    margin: 2rem 0;
    text-align: center;
    animation: explode 1s ease-out forwards;
  }
  
  .explosion-frame {
    color: var(--terminal-cyan);
    font-size: 0.75rem;
    line-height: 1.2;
    text-shadow: 0 0 20px currentColor;
    animation: glow 0.5s ease-in-out infinite alternate;
    font-family: 'JetBrains Mono', 'Courier New', monospace;
  }
  
  .explosion-frame.frame-1 {
    display: block;
    animation-duration: 0.3s;
  }
  
  .explosion-frame.frame-2 {
    display: none;
  }
  
  @keyframes explode {
    0% { 
      opacity: 0; 
      transform: scale(0.5); 
    }
    50% { 
      opacity: 1; 
      transform: scale(1.2); 
    }
    100% { 
      opacity: 1; 
      transform: scale(1); 
    }
  }
  
  @keyframes glow {
    from { text-shadow: 0 0 10px currentColor; }
    to { text-shadow: 0 0 30px currentColor, 0 0 50px currentColor; }
  }
  
  /* Hero Tagline */
  .hero-tagline {
    opacity: 0;
    margin: 3rem 0;
    text-align: center;
    animation: fadeIn 0.8s ease-out forwards;
  }
  
  .hero-title {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(2rem, 5vw, 3.5rem);
    font-weight: 900;
    margin-bottom: 1.5rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }
  
  .hero-subtitle {
    font-size: clamp(1rem, 2vw, 1.25rem);
    color: rgba(255, 255, 255, 0.8);
    line-height: 1.6;
    max-width: 800px;
    margin: 0 auto;
  }
  /* Terminal header styles */
  .terminal-header {
    background: linear-gradient(to bottom, #1a1a1a, #0f0f0f);
    border-bottom: 1px solid rgba(0, 255, 0, 0.3);
    padding: 12px 20px;
    display: flex;
    align-items: center;
    gap: 12px;
    font-family: var(--terminal-font-family);
  }
  /* Terminal buttons container */
  .terminal-buttons {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  /* Terminal button styles */
  .terminal-button {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    display: inline-block;
    flex-shrink: 0;
    transition: all 0.2s ease;
  }
  /* Individual button colors */
  .terminal-button-red {
    background: #ff5f56;
    box-shadow: 0 0 6px rgba(255, 95, 86, 0.5);
  }
  .terminal-button-yellow {
    background: #ffbd2e;
    box-shadow: 0 0 6px rgba(255, 189, 46, 0.5);
  }
  .terminal-button-green {
    background: #27c93f;
    box-shadow: 0 0 6px rgba(39, 201, 63, 0.5);
  }
  /* Button hover effects */
  .terminal-button:hover {
    transform: scale(1.1);
    cursor: pointer;
  }
  /* Terminal title bar */
  .terminal-title {
    flex: 1;
    text-align: center;
    color: var(--terminal-green);
    font-size: 22px;
    font-weight: 400;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    text-shadow: 0 0 3px var(--terminal-green);
    font-family: var(--terminal-font-family);
    opacity: 1;
  }
  
  .text-gradient-cyber {
    background: linear-gradient(135deg, var(--terminal-cyan) 0%, var(--terminal-magenta) 100%);
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.5));
  }
  
  /* Terminal Chat Styles */
  .terminal-chat-section {
    margin-top: 1rem;
    opacity: 0;
    animation: fadeIn 0.3s ease-in forwards;
  }
  
  /* Chat Interface - Full Screen Style */
  .chat-interface {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: transparent;
    padding: 1rem 1.5rem 0 1.5rem;
    font-family: var(--terminal-font-family);
    font-size: 24px;
    display: flex;
    flex-direction: column;
    height: 100%;
    opacity: 0;
    overflow: hidden;
  }
  
  /* Ensure all chat content is properly layered */
  .chat-interface > * {
    position: relative;
    z-index: 1;
  }
  
  /* Hide scrollbar in chat interface */
  .chat-interface::-webkit-scrollbar {
    display: none;
  }
  
  .chat-interface {
    scrollbar-width: none;
    -ms-overflow-style: none;
  }
  
  .chat-interface.active {
    animation: slideUp 0.5s ease-out forwards;
    opacity: 1;
  }
  
  @keyframes slideUp {
    from {
      transform: translateY(100%);
    }
    to {
      transform: translateY(0);
    }
  }
  
  /* Stats Header */
  .chat-stats-header {
    background: rgba(0, 255, 255, 0.05);
    border: 1px solid rgba(0, 255, 255, 0.2);
    border-radius: 4px;
    padding: 0.75rem;
    font-size: 0.75rem;
    position: sticky;
    top: 0;
    z-index: 10;
  }
  
  .stats-row {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 0.25rem;
    font-size: 12px;
  }
  
  .stats-row:last-child {
    margin-bottom: 0;
  }
  
  .stat-label {
    color: var(--terminal-cyan);
    font-weight: 600;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
  }
  
  .stat-value {
    color: var(--terminal-green);
    font-weight: 400;
  }
  
  .stat-separator {
    color: rgba(0, 255, 255, 0.3);
  }
  
  /* Scrollable Chat Container */
  .chat-scroll-container {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    padding-bottom: 0;
    max-height: calc(100% - 100px); /* Account for stats header */
    /* Hide scrollbar but keep scroll functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
  }
  
  /* Hide scrollbar for Chrome, Safari and Opera */
  .chat-scroll-container::-webkit-scrollbar {
    display: none;
  }
  
  /* Chat Container */
  .chat-container {
    display: flex;
    flex-direction: column;
  }
  
  .chat-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    border-bottom: 1px solid rgba(0, 255, 255, 0.2);
    margin-bottom: 1rem;
  }
  
  .chat-title {
    color: var(--terminal-cyan);
    font-size: 1rem;
    font-weight: 600;
  }
  
  .chat-status {
    color: var(--terminal-green);
    font-size: 0.875rem;
  }
  
  .chat-content-area {
    padding: 0 1rem 0.5rem 1rem;
    flex: 1;
    overflow-y: auto;
  }
  
  .chat-message-line {
    margin-top: 1rem;
    margin-bottom: 0;
    text-align: left;
    line-height: 1.0 !important;
  }
  
  /* Force tight line spacing within messages */
  .chat-interface .chat-message-line,
  .terminal-content .chat-message-line {
    line-height: 1.0 !important;
  }
  
  /* First message doesn't need top margin */
  .chat-message-line:first-child {
    margin-top: 0;
  }
  
  /* Reduce spacing for continued messages from same agent */
  .chat-message-line.same-agent {
    margin-top: 0.5rem;
  }
  
  .chat-agent-indicator {
    color: var(--terminal-cyan);
    font-weight: 600;
    margin-right: 0.75rem;
    display: inline;
    vertical-align: baseline;
  }
  
  /* Different colors for each agent */
  .agent-ba {
    color: var(--terminal-cyan);
  }
  
  .agent-sa {
    color: var(--terminal-yellow);
  }
  
  .agent-fs {
    color: var(--terminal-green);
  }
  
  .agent-do {
    color: var(--terminal-red);
  }
  
  .agent-ai {
    color: rgb(255, 0, 255); /* Bright magenta */
  }
  
  .agent-ux {
    color: rgb(255, 165, 0); /* Orange */
  }
  
  .agent-mk {
    color: rgb(150, 150, 255); /* Light purple/blue */
  }
  
  .chat-user-indicator {
    color: rgb(255, 255, 255); /* White for user */
    font-weight: 600;
    margin-right: 0.75rem;
    display: inline;
    vertical-align: baseline;
  }
  
  .chat-text {
    color: var(--terminal-green);
    display: inline;
    line-height: 1.1;
    word-wrap: break-word;
  }
  
  .user-message .chat-text {
    color: rgb(255, 255, 255); /* White for user */
    opacity: 0.9;
  }
  
  /* Match text color to agent color */
  .agent-ba ~ .chat-text {
    color: var(--terminal-cyan) !important;
    opacity: 0.9;
  }
  
  .agent-sa ~ .chat-text {
    color: var(--terminal-yellow) !important;
    opacity: 0.9;
  }
  
  .agent-fs ~ .chat-text {
    color: var(--terminal-green) !important;
    opacity: 0.9;
  }
  
  .agent-do ~ .chat-text {
    color: var(--terminal-red) !important;
    opacity: 0.9;
  }
  
  .agent-ai ~ .chat-text {
    color: rgb(255, 0, 255) !important; /* Bright magenta */
    opacity: 0.9;
  }
  
  .agent-ux ~ .chat-text {
    color: rgb(255, 165, 0) !important; /* Orange */
    opacity: 0.9;
  }
  
  .agent-mk ~ .chat-text {
    color: rgb(150, 150, 255) !important; /* Light purple/blue */
    opacity: 0.9;
  }
  
  .agent-ba ~ .thinking-indicator {
    color: var(--terminal-cyan);
    opacity: 0.7;
  }
  
  .thinking-indicator {
    color: var(--terminal-yellow);
    animation: pulse 1.5s ease-in-out infinite;
  }
  
  @keyframes pulse {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
  }
  
  /* Agent join notifications */
  .agents-joining {
    margin: 0.75rem 0 0.5rem 0;
    padding: 0 1rem;
  }
  
  .agent-join-notification {
    color: var(--terminal-yellow);
    font-size: 20px;
    margin-bottom: 0.25rem;
    margin-left: 3rem;
    opacity: 0;
    animation: fadeIn 0.3s ease-in forwards;
  }
  
  .join-indicator {
    color: var(--terminal-cyan);
    margin-right: 0.5rem;
  }
  
  /* Planning stages - similar style to agent joins */
  .planning-stages {
    margin: 0.75rem 0 0.5rem 0;
    padding: 0 1rem;
  }
  
  .planning-stage-notification {
    color: var(--terminal-yellow);
    font-size: 20px;
    margin-bottom: 0.5rem;
    margin-left: 2rem;
    opacity: 0;
    animation: fadeIn 0.3s ease-in forwards;
  }
  
  .stage-indicator {
    color: var(--terminal-green);
    margin-right: 0.5rem;
    transition: all 0.3s ease;
  }
  
  .planning-stage-notification.completed .stage-text {
    text-decoration: line-through;
    opacity: 0.7;
  }
  
  .planning-stage-notification.completed .stage-indicator {
    color: var(--terminal-green);
    text-shadow: 0 0 10px var(--terminal-green);
  }
  
  /* Branch name styling */
  .branch-name {
    color: var(--terminal-magenta) !important;
    font-weight: 600;
    text-shadow: 0 0 10px var(--terminal-magenta);
    background: rgba(255, 0, 255, 0.1);
    padding: 2px 6px;
    border-radius: 4px;
    border: 1px solid rgba(255, 0, 255, 0.3);
  }
  
  /* Dashboard URL styling */
  .dashboard-url {
    color: var(--terminal-cyan) !important;
    text-decoration: underline;
    text-underline-offset: 2px;
    text-shadow: 0 0 10px var(--terminal-cyan);
    background: rgba(0, 255, 255, 0.1);
    padding: 2px 6px;
    border-radius: 4px;
    border: 1px solid rgba(0, 255, 255, 0.3);
    display: inline;
  }
  
  .dashboard-url:hover {
    color: var(--terminal-yellow) !important;
    cursor: pointer;
    background: rgba(255, 255, 0, 0.1);
    border-color: rgba(255, 255, 0, 0.3);
  }
  
  /* Progress dots animation */
  .progress-dots {
    display: inline-block;
    min-width: 1.5rem;
    text-align: left;
  }
  
  /* Planning stages - similar to agent join notifications */
  .planning-stages {
    margin: 1rem 0;
    padding: 0 1rem;
    max-height: 300px;
    overflow-y: auto;
  }
  
  .planning-stage {
    color: var(--terminal-yellow);
    font-size: 20px;
    margin-bottom: 0.5rem;
    opacity: 0;
    animation: fadeIn 0.3s ease-in forwards;
  }
  
  .planning-stage.complete .stage-text {
    color: var(--terminal-green);
    text-decoration: line-through;
    opacity: 0.7;
  }
  
  .stage-icon {
    color: var(--terminal-cyan);
    margin-right: 0.5rem;
    display: inline-block;
    width: 1rem;
  }
  
  
  @keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
  }
  
  /* Hide scrollbar but keep scroll functionality */
  .terminal-content::-webkit-scrollbar {
    display: none;
  }
  
  /* Hide scrollbar for Firefox */
  .terminal-content {
    scrollbar-width: none;
  }
  
  /* Hide scrollbar for IE and Edge */
  .terminal-content {
    -ms-overflow-style: none;
  }
  
  .typing-animation-chat {
    overflow: visible;
    white-space: normal;
    display: inline;
    text-shadow: 0 0 2px currentColor, 0 0 5px rgba(0, 255, 255, 0.2);
  }
  
  .typing-animation-chat.active {
    /* Character by character animation handled in JS */
  }
  
  .typing-animation-input {
    display: inline;
    overflow: visible;
    white-space: normal;
    color: rgba(255, 255, 255, 0.9);
    text-shadow: 0 0 2px currentColor, 0 0 5px rgba(0, 255, 255, 0.2);
  }
  
  .typing-animation-input.active {
    /* Character by character animation handled in JS */
  }
  
  @keyframes typing-chat {
    from { width: 0; }
    to { width: 100%; }
  }
  
  .chat-cursor {
    display: none; /* Hidden by default, shown only during typing */
    width: 2px;
    height: 1em;
    background: var(--terminal-green);
    animation: blink-caret 0.75s step-end infinite;
    vertical-align: text-bottom;
    margin-left: 2px;
  }
  
  .user-cursor {
    background: var(--terminal-magenta);
  }
  
  
  /* Mobile responsive */
  @media (max-width: 768px) {
    .terminal-lines {
      font-size: 12px;
      padding: 1rem;
    }
    
    .explosion-frame {
      font-size: 0.5rem;
    }
    
    .hero-title {
      font-size: 2rem;
    }
    
    .hero-subtitle {
      font-size: 1rem;
    }
    
  }
</style>

<!-- Global styles for dynamically generated content -->
<style is:global>
  /* Ensure all dynamic content uses terminal font */
  .terminal-content {
    font-family: var(--terminal-font-family);
  }
  
  /* Add subtle glow to all terminal text */
  .terminal-content *,
  .terminal-content .chat-interface *,
  .chat-interface .chat-text,
  .chat-interface .chat-agent-indicator,
  .chat-interface .chat-user-indicator,
  .chat-interface .stat-label,
  .chat-interface .stat-value {
    text-shadow: 0 0 2px currentColor, 0 0 5px rgba(0, 255, 255, 0.2) !important;
  }
  
  /* Stats header styling */
  .terminal-content .chat-stats-header {
    background: rgba(0, 255, 255, 0.05);
    border: 1px solid rgba(0, 255, 255, 0.2);
    border-radius: 4px;
    padding: 0.75rem;
    font-size: 0.75rem;
    position: sticky;
    top: 0;
    z-index: 10;
    margin-bottom: 1rem;
  }
  
  .terminal-content .stats-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.25rem;
    white-space: nowrap;
    overflow-x: auto;
    overflow-y: hidden;
  }
  
  /* Hide scrollbar but keep functionality */
  .terminal-content .stats-row::-webkit-scrollbar {
    height: 0;
  }
  
  /* Responsive stats header */
  @media (max-width: 768px) {
    .terminal-content .chat-stats-header {
      font-size: 0.6rem;
      padding: 0.5rem;
    }
    
    .terminal-content .stats-row {
      gap: 0.5rem;
    }
    
    .terminal-content .stat-label {
      font-size: 0.55rem;
    }
    
    .terminal-content .stat-value {
      font-size: 0.6rem;
    }
  }
  
  .terminal-content .stats-row:last-child {
    margin-bottom: 0;
  }
  
  .terminal-content .stat-label {
    color: var(--terminal-cyan);
    font-weight: 600;
    text-transform: uppercase;
    font-size: 0.7rem;
  }
  
  .terminal-content .stat-value {
    color: var(--terminal-green);
    font-weight: 400;
  }
  
  .terminal-content .stat-separator {
    color: rgba(0, 255, 255, 0.3);
  }
  
  .terminal-content .chat-agent-indicator {
    color: var(--terminal-cyan);
    font-weight: 600;
    margin-right: 0.75rem;
  }
  
  /* Different colors for each agent */
  .terminal-content .agent-ba {
    color: var(--terminal-cyan);
  }
  
  .terminal-content .agent-sa {
    color: var(--terminal-yellow);
  }
  
  .terminal-content .agent-fs {
    color: var(--terminal-green);
  }
  
  .terminal-content .agent-do {
    color: var(--terminal-red);
  }
  
  .terminal-content .agent-ai {
    color: var(--terminal-magenta);
  }
  
  .terminal-content .agent-ux {
    color: rgb(255, 165, 0); /* Orange */
  }
  
  .terminal-content .agent-mk {
    color: rgb(150, 150, 255); /* Light purple/blue */
  }
  
  .terminal-content .chat-user-indicator {
    color: var(--terminal-magenta);
    font-weight: 600;
    margin-right: 0.75rem;
  }
  
  .terminal-content .chat-text {
    color: var(--terminal-green);
    display: inline;
    line-height: 1.1;
  }
  
  .terminal-content .user-message .chat-text {
    color: var(--terminal-magenta);
    opacity: 0.9;
  }
  
  /* Match text color to agent color */
  .terminal-content .agent-ba ~ .chat-text {
    color: var(--terminal-cyan) !important;
    opacity: 0.9;
  }
  
  .terminal-content .agent-sa ~ .chat-text {
    color: var(--terminal-yellow) !important;
    opacity: 0.9;
  }
  
  .terminal-content .agent-fs ~ .chat-text {
    color: var(--terminal-green) !important;
    opacity: 0.9;
  }
  
  .terminal-content .agent-do ~ .chat-text {
    color: var(--terminal-red) !important;
    opacity: 0.9;
  }
  
  .terminal-content .agent-ai ~ .chat-text {
    color: var(--terminal-magenta) !important;
    opacity: 0.9;
  }
  
  .terminal-content .agent-ux ~ .chat-text {
    color: rgb(255, 165, 0) !important;
    opacity: 0.9;
  }
  
  .terminal-content .agent-mk ~ .chat-text {
    color: rgb(150, 150, 255) !important; /* Light purple/blue */
    opacity: 0.9;
  }
  
  .terminal-content .agent-ba ~ .thinking-indicator {
    color: var(--terminal-cyan);
    opacity: 0.7;
  }
  
  .terminal-content .thinking-indicator {
    color: var(--terminal-yellow);
    animation: pulse 1.5s ease-in-out infinite;
  }
  
  /* Agent join notifications */
  .terminal-content .agent-join-notification {
    color: var(--terminal-yellow);
    font-size: 20px;
    margin-bottom: 0.75rem;
    font-style: italic;
    opacity: 0.9;
    padding-left: 3rem;
  }
  
  .terminal-content .join-indicator {
    color: var(--terminal-green);
    margin-right: 0.5rem;
  }
  
  /* Terminal prompt styling for dynamic content */
  .terminal-content .terminal-prompt {
    color: var(--terminal-cyan);
    margin-right: 0.5rem;
  }
  
  .terminal-content .terminal-command {
    color: var(--terminal-green);
  }
  
  .terminal-content .terminal-loading {
    color: var(--terminal-yellow);
    animation: pulse 1.5s ease-in-out infinite;
  }
  
  .terminal-content .terminal-success {
    color: var(--terminal-green);
  }
  
  /* Terminal cursor blink */
  .terminal-content .terminal-cursor-blink {
    color: var(--terminal-green);
    animation: blink 1s step-end infinite;
    font-weight: bold;
  }
  
  /* ASCII explosion styling */
  .terminal-content .ascii-explosion {
    text-align: center;
    margin: 2rem 0;
    position: relative;
  }
  
  .terminal-content .explosion-frame {
    color: var(--terminal-green);
    font-size: 0.875rem;
    line-height: 1.2;
    white-space: pre;
    font-family: 'JetBrains Mono', 'Fira Code', monospace;
    text-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
    font-weight: 400;
  }
  
  .terminal-content .explosion-frame.frame-2 {
    font-size: 0.7rem;
    color: var(--terminal-cyan);
    text-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
  }
  
  /* Planning stages with proper indentation */
  .terminal-content .planning-stages {
    margin: 1rem 0;
    padding: 0 2rem;
  }
  
  .terminal-content .planning-stage-notification {
    color: var(--terminal-yellow);
    font-size: 20px;
    margin-bottom: 0.5rem;
    padding-left: 3rem;
    opacity: 0;
    animation: fadeIn 0.3s ease-in forwards;
  }
  
  .terminal-content .planning-stage-notification.completed {
    opacity: 0.7;
  }
  
  .terminal-content .planning-stage-notification.completed .stage-indicator {
    color: var(--terminal-green);
  }
  
  .terminal-content .planning-stage-notification.completed .stage-text {
    color: var(--terminal-green);
    text-decoration: line-through;
  }
  
  .terminal-content .stage-indicator {
    color: var(--terminal-yellow);
    margin-right: 0.5rem;
  }
  
  .terminal-content .stage-text {
    color: var(--terminal-yellow);
  }
  
  /* Branch creation styling */
  .terminal-content .branch-name {
    color: var(--terminal-cyan);
    font-weight: 600;
  }
  
  /* Dashboard URL styling */
  .terminal-content .dashboard-url {
    color: var(--terminal-cyan) !important;
    text-decoration: underline;
    text-underline-offset: 2px;
  }
  
  /* Progress indicator styling */
  .terminal-content .progress-dots {
    display: inline-block;
    min-width: 1.5rem;
    text-align: left;
  }
  
  /* Scrollable chat container */
  .terminal-content .chat-scroll-container {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    padding-bottom: 0;
    max-height: calc(100% - 100px);
    /* Hide scrollbar but keep scroll functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
  }
  
  /* Hide scrollbar for Chrome, Safari and Opera */
  .terminal-content .chat-scroll-container::-webkit-scrollbar {
    display: none;
  }
  
  /* Chat container */
  .terminal-content .chat-container {
    display: flex;
    flex-direction: column;
  }
  
  .terminal-content .chat-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    border-bottom: 1px solid rgba(0, 255, 255, 0.2);
    margin-bottom: 1rem;
  }
  
  .terminal-content .chat-title {
    color: var(--terminal-cyan);
    font-size: 1rem;
    font-weight: 600;
  }
  
  .terminal-content .chat-status {
    color: var(--terminal-green);
    font-size: 0.875rem;
  }
  
  .terminal-content .chat-content-area {
    padding: 0 1rem;
    flex: 1;
    overflow-y: auto;
  }
  
  /* Make chat interface take full height */
  .terminal-content .chat-interface {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Get scenario data from the terminal content element
    const terminalContent = document.querySelector('.terminal-content');
    const allScenarios = JSON.parse(terminalContent.getAttribute('data-scenarios'));
    const scenarioIds = JSON.parse(terminalContent.getAttribute('data-scenario-ids'));
    const initialScenarioId = terminalContent.getAttribute('data-current-scenario');
    
    let currentScenarioIndex = scenarioIds.indexOf(initialScenarioId);
    if (currentScenarioIndex === -1) currentScenarioIndex = 0;
    
    // Function to generate terminal content from scenario data
    function generateTerminalContent(scenario) {
      const terminalLines = document.querySelector('.terminal-lines');
      const terminalPhase = scenario.phases.find(p => p.type === 'terminal');
      
      if (!terminalPhase) return;
      
      terminalPhase.items.forEach(item => {
        if (item.type === 'command') {
          const lineDiv = document.createElement('div');
          lineDiv.className = 'terminal-line';
          lineDiv.setAttribute('data-delay', item.delay);
          lineDiv.style.display = 'none';
          
          if (item.noType) {
            // Command appears instantly without typing animation
            lineDiv.innerHTML = `
              <span class="terminal-prompt">${item.prompt}</span>
              <span class="terminal-command">${item.text}</span>
            `;
          } else {
            lineDiv.innerHTML = `
              <span class="terminal-prompt">${item.prompt}</span>
              <span class="terminal-command">
                <span class="typing-animation" data-text="${item.text}" data-duration="${item.duration}" style="opacity: 0;"></span>
              </span>
            `;
          }
          terminalLines.appendChild(lineDiv);
        } else if (item.type === 'loading') {
          const lineDiv = document.createElement('div');
          lineDiv.className = 'terminal-line loading-line';
          lineDiv.setAttribute('data-delay', item.delay);
          lineDiv.innerHTML = `<span class="terminal-loading">${item.text}</span>`;
          terminalLines.appendChild(lineDiv);
        } else if (item.type === 'ascii') {
          const asciiDiv = document.createElement('div');
          asciiDiv.className = 'ascii-explosion';
          asciiDiv.setAttribute('data-delay', item.delay);
          item.frames.forEach((frame, index) => {
            const preElement = document.createElement('pre');
            preElement.className = `explosion-frame frame-${index + 1}`;
            if (index > 0) preElement.style.display = 'none';
            preElement.textContent = frame;
            asciiDiv.appendChild(preElement);
          });
          terminalLines.appendChild(asciiDiv);
        } else if (item.type === 'success') {
          const lineDiv = document.createElement('div');
          lineDiv.className = 'terminal-line success-line';
          lineDiv.setAttribute('data-delay', item.delay);
          lineDiv.innerHTML = `<span class="terminal-success">${item.text}</span>`;
          terminalLines.appendChild(lineDiv);
        } else if (item.type === 'finalPrompt') {
          const lineDiv = document.createElement('div');
          lineDiv.className = 'terminal-line';
          lineDiv.setAttribute('data-delay', item.delay);
          lineDiv.innerHTML = `
            <span class="terminal-prompt">$</span>
            <span class="terminal-cursor-blink">_</span>
          `;
          terminalLines.appendChild(lineDiv);
        }
      });
    }
    
    // Function to generate chat content from scenario data
    function generateChatContent(scenario) {
      const chatInterface = document.querySelector('.chat-interface');
      const chatPhase = scenario.phases.find(p => p.type === 'chat');
      
      if (!chatPhase) return;
      
      // Create chat structure
      const chatHTML = `
        <div class="chat-stats-header">
          <div class="stats-row">
            <span class="stat-label">PROJECT:</span> <span class="stat-value">${chatPhase.stats.project}</span>
            <span class="stat-separator">|</span>
            <span class="stat-label">FILES:</span> <span class="stat-value">${chatPhase.stats.files}</span>
            <span class="stat-separator">|</span>
            <span class="stat-label">FUNCTIONS:</span> <span class="stat-value">${chatPhase.stats.functions}</span>
          </div>
          <div class="stats-row">
            <span class="stat-label">AGENTS:</span> <span class="stat-value">${chatPhase.stats.agents}</span>
            <span class="stat-separator">|</span>
            <span class="stat-label">CONTEXT:</span> <span class="stat-value">${chatPhase.stats.context}</span>
            <span class="stat-separator">|</span>
            <span class="stat-label">MODE:</span> <span class="stat-value">${chatPhase.stats.mode}</span>
          </div>
        </div>
        
        <div class="chat-scroll-container">
          <div class="chat-container">
            <div class="chat-header">
              <span class="chat-title">${chatPhase.chatTitle}</span>
              <span class="chat-status">● Connected</span>
            </div>
            <div class="chat-content-area"></div>
          </div>
        </div>
      `;
      
      chatInterface.innerHTML = chatHTML;
      const chatContentArea = chatInterface.querySelector('.chat-content-area');
      
      // Process messages
      let previousAgent = null;
      chatPhase.messages.forEach((message, index) => {
        if (message.type === 'agent') {
          const messageDiv = createAgentMessage(message, scenario.agents[message.agent]);
          if (index > 0) messageDiv.style.display = 'none';
          // Add same-agent class if this is from the same agent as previous
          if (previousAgent === message.agent) {
            messageDiv.classList.add('same-agent');
          }
          previousAgent = message.agent;
          chatContentArea.appendChild(messageDiv);
        } else if (message.type === 'user') {
          const messageDiv = createUserMessage(message);
          messageDiv.style.display = 'none';
          previousAgent = 'user';
          chatContentArea.appendChild(messageDiv);
        } else if (message.type === 'thinking') {
          const messageDiv = createThinkingMessage(message, scenario.agents[message.agent]);
          messageDiv.style.display = 'none';
          // Don't change previousAgent for thinking messages
          chatContentArea.appendChild(messageDiv);
        } else if (message.type === 'agentsJoining') {
          const joinDiv = createAgentsJoining(message.agents);
          joinDiv.style.display = 'none';
          previousAgent = null; // Reset after system messages
          chatContentArea.appendChild(joinDiv);
        } else if (message.type === 'multipart') {
          const messageDiv = createMultipartMessage(message, scenario.agents[message.agent]);
          messageDiv.style.display = 'none';
          // Add same-agent class if this is from the same agent as previous
          if (previousAgent === message.agent) {
            messageDiv.classList.add('same-agent');
          }
          previousAgent = message.agent;
          chatContentArea.appendChild(messageDiv);
        } else if (message.type === 'planningAnnouncement') {
          const messageDiv = createPlanningAnnouncement(message, scenario.agents[message.agent]);
          messageDiv.style.display = 'none';
          previousAgent = null; // Reset after system messages
          chatContentArea.appendChild(messageDiv);
        } else if (message.type === 'planningStages') {
          const stagesDiv = createPlanningStages(message.stages);
          stagesDiv.style.display = 'none';
          previousAgent = null; // Reset after system messages
          chatContentArea.appendChild(stagesDiv);
        } else if (message.type === 'branchCreation') {
          const messageDiv = createBranchCreation(message, scenario.agents[message.agent]);
          messageDiv.style.display = 'none';
          previousAgent = null; // Reset after system messages
          chatContentArea.appendChild(messageDiv);
        } else if (message.type === 'dashboardLink') {
          const messageDiv = createDashboardLink(message, scenario.agents[message.agent]);
          messageDiv.style.display = 'none';
          previousAgent = null; // Reset after system messages
          chatContentArea.appendChild(messageDiv);
        } else if (message.type === 'progressIndicator') {
          const messageDiv = createProgressIndicator(message, scenario.agents[message.agent]);
          messageDiv.style.display = 'none';
          previousAgent = null; // Reset after system messages
          chatContentArea.appendChild(messageDiv);
        }
      });
    }
    
    // Helper functions to create different message types
    function createAgentMessage(message, agent) {
      const div = document.createElement('div');
      div.className = 'chat-message-line';
      div.innerHTML = `
        <span class="chat-agent-indicator ${agent.class}">[${message.agent}]</span>
        <span class="chat-text typing-animation-chat" data-text="${message.text}" data-duration="${message.duration}"></span>
        <span class="chat-cursor" style="display: none;"></span>
      `;
      return div;
    }
    
    function createUserMessage(message) {
      const div = document.createElement('div');
      div.className = 'chat-message-line user-message';
      div.innerHTML = `
        <span class="chat-user-indicator">[You]</span>
        <span class="chat-text typing-animation-chat user-typing" data-text="${message.text}" data-duration="${message.duration}"></span>
        <span class="chat-cursor user-cursor"></span>
      `;
      return div;
    }
    
    function createThinkingMessage(message, agent) {
      const div = document.createElement('div');
      div.className = 'chat-message-line';
      div.innerHTML = `
        <span class="chat-agent-indicator ${agent.class}">[${message.agent}]</span>
        <span class="thinking-indicator">${message.text}</span>
      `;
      return div;
    }
    
    function createAgentsJoining(agents) {
      const div = document.createElement('div');
      div.className = 'agents-joining';
      agents.forEach(agentName => {
        const notification = document.createElement('div');
        notification.className = 'agent-join-notification';
        notification.style.display = 'none';
        notification.innerHTML = `<span class="join-indicator">→</span> ${agentName} has joined the conversation`;
        div.appendChild(notification);
      });
      return div;
    }
    
    function createMultipartMessage(message, agent) {
      const div = document.createElement('div');
      div.className = 'chat-message-line';
      div.innerHTML = `
        <span class="chat-agent-indicator ${agent.class}">[${message.agent}]</span>
        <span class="chat-text">
          ${message.parts.map((part, i) => 
            `<span class="typing-animation-chat" data-text="${part.text}" data-duration="${part.duration}"${i > 0 ? ' style="display: none;"' : ''}></span>`
          ).join('')}
        </span>
        <span class="chat-cursor"></span>
      `;
      return div;
    }
    
    function createPlanningAnnouncement(message, agent) {
      const div = document.createElement('div');
      div.className = 'chat-message-line planning-announcement';
      div.innerHTML = `
        <span class="chat-agent-indicator ${agent.class}">[${message.agent}]</span>
        <span class="chat-text typing-animation-chat" data-text="${message.text}" data-duration="${message.duration}"></span>
        <span class="chat-cursor"></span>
      `;
      return div;
    }
    
    function createPlanningStages(stages) {
      const div = document.createElement('div');
      div.className = 'planning-stages';
      stages.forEach(stage => {
        const stageDiv = document.createElement('div');
        stageDiv.className = 'planning-stage-notification';
        stageDiv.style.display = 'none';
        stageDiv.setAttribute('data-stage-delay', stage.delay);
        stageDiv.innerHTML = `
          <span class="stage-indicator">☐</span> 
          <span class="stage-text">${stage.text}</span>
        `;
        div.appendChild(stageDiv);
      });
      return div;
    }
    
    function createBranchCreation(message, agent) {
      const div = document.createElement('div');
      div.className = 'chat-message-line branch-creation';
      div.innerHTML = `
        <span class="chat-agent-indicator ${agent.class}">[${message.agent}]</span>
        <span class="chat-text">
          <span class="typing-animation-chat" data-text="Creating branch: " data-duration="0.5"></span>
          <span class="typing-animation-chat branch-name" data-text="${message.branchName}" data-duration="0.5"></span>
          <span class="typing-animation-chat" data-text="..." data-duration="0.3"></span>
        </span>
        <span class="chat-cursor"></span>
      `;
      return div;
    }
    
    function createDashboardLink(message, agent) {
      const div = document.createElement('div');
      div.className = 'chat-message-line dashboard-link';
      div.innerHTML = `
        <span class="chat-agent-indicator ${agent.class}">[${message.agent}]</span>
        <span class="chat-text typing-animation-chat dashboard-url" data-text="${message.url}" data-duration="${message.duration}"></span>
        <span class="chat-cursor"></span>
      `;
      return div;
    }
    
    function createProgressIndicator(message, agent) {
      const div = document.createElement('div');
      div.className = 'chat-message-line progress-indicator';
      div.innerHTML = `
        <span class="chat-agent-indicator ${agent.class}">[${message.agent}]</span>
        <span class="chat-text">${message.text}<span class="progress-dots"></span></span>
      `;
      return div;
    }
    
    // Function to clear and regenerate content for a new scenario
    function loadScenario(scenarioId) {
      // Clear existing content
      document.querySelector('.terminal-lines').innerHTML = `
        <div class="terminal-line initial-prompt">
          <span class="terminal-prompt">$</span>
          <span class="initial-cursor"></span>
        </div>
      `;
      document.querySelector('.chat-interface').innerHTML = '';
      
      // Update terminal title
      const titleElement = document.querySelector('.terminal-title');
      if (titleElement) {
        titleElement.textContent = allScenarios[scenarioId].terminalTitle;
      }
      
      // Generate new content
      generateTerminalContent(allScenarios[scenarioId]);
      generateChatContent(allScenarios[scenarioId]);
    }
    
    // Load initial scenario
    loadScenario(scenarioIds[currentScenarioIndex]);
    
    const elements = document.querySelectorAll('[data-delay]');
    const terminalLines = document.querySelector('.terminal-lines');
    const initialPrompt = document.querySelector('.initial-prompt');
    
    // Clear all typing animations on load
    document.querySelectorAll('.typing-animation, .typing-animation-chat').forEach(el => {
      el.textContent = '';
    });
    
    // Initialize audio context on first user interaction
    let audioContext = null;
    const initAudio = () => {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        window.audioContext = audioContext;
      }
    };
    
    // Create typing sound
    function playTypingSound() {
      if (!audioContext) return;
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = 800 + Math.random() * 400; // Random frequency between 800-1200 Hz
      gainNode.gain.value = 0.02; // Very quiet
      
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.01); // Very short beep
    }
    
    // Initialize audio on any click
    document.addEventListener('click', initAudio, { once: true });
    
    function resetAnimation() {
      // Hide all animated elements
      elements.forEach(el => {
        el.style.display = 'none';
        el.classList.remove('animate');
        el.style.opacity = '0';
        
        // Reset typing animations
        const typing = el.querySelector('.typing-animation');
        if (typing) {
          typing.classList.remove('active');
          typing.style.borderRight = '2px solid var(--terminal-green)';
          typing.textContent = '';
        }
        
        const typingChat = el.querySelector('.typing-animation-chat');
        if (typingChat) {
          typingChat.classList.remove('active');
          typingChat.classList.remove('typed');
          typingChat.textContent = '';
        }
      });
      
      // Reset explosion frames
      const frame1 = document.querySelector('.explosion-frame.frame-1');
      const frame2 = document.querySelector('.explosion-frame.frame-2');
      if (frame1) frame1.style.display = 'block';
      if (frame2) frame2.style.display = 'none';
      
      // Show initial prompt with cursor
      if (initialPrompt) {
        initialPrompt.style.display = 'block';
        initialPrompt.style.opacity = '1';
      }
      
      // Reset terminal lines visibility
      const terminalLines = document.querySelector('.terminal-lines');
      if (terminalLines) {
        terminalLines.style.display = 'block';
        terminalLines.style.opacity = '1';
      }
      
      // Reset chat interface
      const chatInterface = document.querySelector('.chat-interface');
      if (chatInterface) {
        chatInterface.classList.remove('active');
        // Clear all typing animations in chat
        chatInterface.querySelectorAll('.typing-animation-chat').forEach(el => {
          el.textContent = '';
          el.classList.remove('typed');
        });
      }
      
      // Reset branch creation section
      const branchSection = document.querySelector('.branch-creation-section');
      if (branchSection) {
        branchSection.style.display = 'none';
        branchSection.style.opacity = '0';
        const branchStatus = branchSection.querySelector('.branch-status');
        const buildingAnim = branchSection.querySelector('.building-animation');
        const dashboardLink = branchSection.querySelector('.dashboard-link');
        if (branchStatus) branchStatus.style.display = 'none';
        if (buildingAnim) buildingAnim.style.display = 'none';
        if (dashboardLink) dashboardLink.style.display = 'none';
      }
    }
    
    function runAnimation() {
      resetAnimation();
      
      elements.forEach((element) => {
        const delay = parseInt(element.getAttribute('data-delay') || '0');
        
        setTimeout(() => {
          // Hide initial prompt when first command starts typing
          if (delay === 2000 && initialPrompt) {
            initialPrompt.style.display = 'none';
          }
          
          element.style.display = 'block';
          element.style.opacity = '1';
          element.classList.add('animate');
          
          // Handle typing animation character by character
          const typingElement = element.querySelector('.typing-animation');
          if (typingElement) {
            const text = typingElement.getAttribute('data-text') || '';
            const duration = typingElement.getAttribute('data-duration') || '2.5';
            const msPerChar = (parseFloat(duration) * 1000) / text.length;
            
            typingElement.style.opacity = '1';
            typingElement.classList.add('active');
            typingElement.textContent = '';
            
            // Type each character with punctuation pauses
            let charIndex = 0;
            function typeCommand() {
              if (charIndex < text.length) {
                typingElement.textContent += text[charIndex];
                
                // Play typing sound
                if (window.audioContext) {
                  playTypingSound();
                }
                
                // Check for punctuation
                const char = text[charIndex];
                const isPunctuation = ['.', ',', ':', ';', '!', '?'].includes(char);
                charIndex++;
                
                if (isPunctuation && charIndex < text.length) {
                  setTimeout(typeCommand, msPerChar + 300 + Math.random() * 200);
                } else if (charIndex < text.length) {
                  setTimeout(typeCommand, msPerChar);
                } else {
                  // Remove cursor after typing completes
                  setTimeout(() => {
                    typingElement.style.borderRight = 'none';
                  }, 200);
                }
              }
            }
            typeCommand();
          }
          
          // Show explosion frame 2 after frame 1
          if (element.classList.contains('ascii-explosion')) {
            setTimeout(() => {
              const frame1 = element.querySelector('.frame-1');
              const frame2 = element.querySelector('.frame-2');
              if (frame1) frame1.style.display = 'none';
              if (frame2) frame2.style.display = 'block';
            }, 300);
          }
          
          // Handle terminal chat section typing animation
          if (element.classList.contains('terminal-chat-section')) {
            setTimeout(() => {
              const chatText = element.querySelector('.typing-animation-chat');
              if (chatText) {
                chatText.classList.add('active');
              }
            }, 500);
          }
          
          // Handle chat interface - hide terminal lines when chat appears
          if (element.classList.contains('chat-interface')) {
            element.classList.add('active');
            const terminalLines = document.querySelector('.terminal-lines');
            if (terminalLines) {
              // Fade out terminal lines
              terminalLines.style.transition = 'opacity 0.3s ease-out';
              terminalLines.style.opacity = '0';
              setTimeout(() => {
                terminalLines.style.display = 'none';
              }, 300);
            }
            
            // Sequential chat message system
            const chatContentArea = element.querySelector('.chat-content-area');
            const chatMessages = chatContentArea ? chatContentArea.querySelectorAll('.chat-message-line, .agents-joining, .planning-stages') : [];
            let messageIndex = 0;
            
            // Hide all messages initially (except the first one which is already visible)
            chatMessages.forEach((msg, index) => {
              if (index > 0) {
                msg.style.display = 'none';
                msg.style.opacity = '0';
              }
            });
            
            function showNextMessage() {
              if (messageIndex >= chatMessages.length) {
                // All messages shown, wait then move to next scenario
                setTimeout(() => {
                  // Move to next scenario
                  currentScenarioIndex = (currentScenarioIndex + 1) % scenarioIds.length;
                  loadScenario(scenarioIds[currentScenarioIndex]);
                  // Restart animation with new scenario
                  runAnimation();
                }, 30000);
                return;
              }
              
              // Rest of the message handling...
              const currentMessage = chatMessages[messageIndex];
              
              // Show the message
              currentMessage.style.display = 'block';
              currentMessage.style.opacity = '1';
              
              // Scroll to show new message
              const scrollContainer = element.querySelector('.chat-scroll-container') || chatContentArea;
              if (scrollContainer) {
                setTimeout(() => {
                  scrollContainer.scrollTo({
                    top: scrollContainer.scrollHeight,
                    behavior: 'smooth'
                  });
                }, 100);
              }
              
              // Check if this message has typing animation(s)
              const typingEls = currentMessage.querySelectorAll('.typing-animation-chat:not(.typed)');
              if (typingEls.length > 0) {
                // Handle multi-part messages
                if (typingEls.length > 1) {
                  let partIndex = 0;
                  const cursor = currentMessage.querySelector('.chat-cursor');
                  if (cursor) cursor.style.display = 'inline-block';
                  
                  // Ensure scrolling during multi-part typing
                  let scrollInterval = setInterval(() => {
                    if (scrollContainer) {
                      scrollContainer.scrollTo({
                        top: scrollContainer.scrollHeight,
                        behavior: 'smooth'
                      });
                    }
                  }, 500);
                  
                  function typeNextPart() {
                    if (partIndex < typingEls.length) {
                      const typingEl = typingEls[partIndex];
                      const text = typingEl.getAttribute('data-text') || '';
                      const duration = typingEl.getAttribute('data-duration') || '0.4';
                      const msPerChar = (parseFloat(duration) * 1000) / text.length;
                      
                      // Show this part if it's hidden
                      if (typingEl.style.display === 'none') {
                        typingEl.style.display = 'inline';
                      }
                      
                      typingEl.classList.add('active');
                      typingEl.classList.add('typed');
                      typingEl.textContent = '';
                      
                      let charIndex = 0;
                      function typePartChar() {
                        if (charIndex < text.length) {
                          typingEl.textContent += text[charIndex];
                          if (window.audioContext) playTypingSound();
                          
                          const char = text[charIndex];
                          const isPunctuation = ['.', ',', ':', ';', '!', '?'].includes(char);
                          charIndex++;
                          
                          if (isPunctuation && charIndex < text.length) {
                            setTimeout(typePartChar, msPerChar + 300 + Math.random() * 200);
                          } else if (charIndex < text.length) {
                            setTimeout(typePartChar, msPerChar);
                          } else {
                            // Part done, move to next
                            partIndex++;
                            setTimeout(typeNextPart, 300); // Small pause between parts
                          }
                        }
                      }
                      typePartChar();
                    } else {
                      // All parts done
                      if (scrollInterval) clearInterval(scrollInterval);
                      if (cursor) cursor.style.display = 'none';
                      messageIndex++;
                      setTimeout(showNextMessage, 1500);
                    }
                  }
                  typeNextPart();
                } else {
                  // Single typing animation
                  const typingEl = typingEls[0];
                  const text = typingEl.getAttribute('data-text') || '';
                  const duration = typingEl.getAttribute('data-duration') || '2';
                  const msPerChar = (parseFloat(duration) * 1000) / text.length;
                  
                  typingEl.classList.add('active');
                  typingEl.classList.add('typed');
                  typingEl.textContent = '';
                  
                  // Show cursor for this message
                  const cursor = currentMessage.querySelector('.chat-cursor');
                  if (cursor) {
                    cursor.style.display = 'inline-block';
                  }
                  
                  let charIndex = 0;
                  let scrollInterval = null;
                  
                  // Start continuous scrolling during typing
                  if (scrollContainer) {
                    scrollInterval = setInterval(() => {
                      scrollContainer.scrollTo({
                        top: scrollContainer.scrollHeight,
                        behavior: 'smooth'
                      });
                    }, 500);
                  }
                  
                  function typeWithPunctuation() {
                    if (charIndex < text.length) {
                      typingEl.textContent += text[charIndex];
                      if (window.audioContext) {
                        playTypingSound();
                      }
                      
                      // Check if we just typed punctuation
                      const char = text[charIndex];
                      const isPunctuation = ['.', ',', ':', ';', '!', '?'].includes(char);
                      charIndex++;
                      
                      if (isPunctuation && charIndex < text.length) {
                        // Pause after punctuation
                        setTimeout(typeWithPunctuation, msPerChar + 300 + Math.random() * 200);
                      } else if (charIndex < text.length) {
                        // Continue normally
                        setTimeout(typeWithPunctuation, msPerChar);
                      } else {
                        // Done typing
                        if (scrollInterval) clearInterval(scrollInterval);
                        if (cursor) cursor.style.display = 'none';
                        messageIndex++;
                        const pauseDuration = currentMessage.classList.contains('user-message') ? 2000 : 1500;
                        setTimeout(showNextMessage, pauseDuration);
                      }
                    }
                  }
                  
                  // Start typing
                  typeWithPunctuation();
                }
              } 
              // Handle thinking indicator (no typing)
              else if (currentMessage.querySelector('.thinking-indicator')) {
                // Show thinking for 2.5 seconds
                messageIndex++;
                setTimeout(showNextMessage, 2500);
              }
              // Handle agent joining section
              else if (currentMessage.classList.contains('agents-joining')) {
                // Show all join notifications with small delays
                const joinNotifications = currentMessage.querySelectorAll('.agent-join-notification');
                let joinIndex = 0;
                
                function showNextJoin() {
                  if (joinIndex < joinNotifications.length) {
                    joinNotifications[joinIndex].style.display = 'block';
                    joinNotifications[joinIndex].style.opacity = '1';
                    joinIndex++;
                    setTimeout(showNextJoin, 200);
                  } else {
                    // All agents joined, continue to next message
                    messageIndex++;
                    setTimeout(showNextMessage, 1500);
                  }
                }
                showNextJoin();
              }
              // Handle planning stages section
              else if (currentMessage.classList.contains('planning-stages')) {
                // Show all planning stages with delays between each
                const stages = currentMessage.querySelectorAll('.planning-stage-notification');
                let stageIndex = 0;
                
                function showNextStage() {
                  if (stageIndex < stages.length) {
                    const stage = stages[stageIndex];
                    stage.style.display = 'block';
                    stage.style.opacity = '1';
                    
                    // Scroll to show new stage
                    if (scrollContainer) {
                      scrollContainer.scrollTo({
                        top: scrollContainer.scrollHeight,
                        behavior: 'smooth'
                      });
                    }
                    
                    // After a pause, check it off and show the next one
                    const stageDelay = stage.getAttribute('data-stage-delay') || '2500';
                    setTimeout(() => {
                      const indicator = stage.querySelector('.stage-indicator');
                      if (indicator) {
                        indicator.textContent = '☑';
                        stage.classList.add('completed');
                      }
                      stageIndex++;
                      // Check if this was the last stage
                      if (stageIndex < stages.length) {
                        // More stages to show - show next immediately
                        showNextStage();
                      } else {
                        // This was the last stage - continue to next message quickly
                        messageIndex++;
                        setTimeout(showNextMessage, 1000);
                      }
                    }, parseInt(stageDelay)); // Use the delay from the data
                  } else {
                    // This shouldn't happen but handle it just in case
                    messageIndex++;
                    setTimeout(showNextMessage, 1000);
                  }
                }
                showNextStage();
              }
              else {
                // Check if this is the progress indicator (last message)
                if (currentMessage.classList.contains('progress-indicator')) {
                  // Show progress dots animation
                  const progressDots = currentMessage.querySelector('.progress-dots');
                  if (progressDots) {
                    let dotCount = 0;
                    setInterval(() => {
                      dotCount = (dotCount + 1) % 4;
                      progressDots.textContent = '.'.repeat(dotCount);
                    }, 500);
                  }
                  
                  // Wait longer before restarting
                  messageIndex++;
                  setTimeout(showNextMessage, 5000);
                } else {
                  // No animation, just continue
                  messageIndex++;
                  setTimeout(showNextMessage, 1000);
                }
              }
            }
            
            
            // Start the conversation after 1.5 seconds
            setTimeout(showNextMessage, 1500);
          }
        }, delay);
      });
    }
    
    // Start the animation
    runAnimation();
  });
</script>